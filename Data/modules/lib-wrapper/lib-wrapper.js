const e="lib-wrapper";let t="",i=-1,r=-1,n=-1,s=-1,a="",o="",c="",l="";const p="undefined"==typeof Game,d=!!p;let h=!1;const _=["WRAPPER","MIXED","OVERRIDE"];Object.freeze(_);const g={WRAPPER:1,MIXED:2,OVERRIDE:3};Object.freeze(g);const f={};for(let e in g)f[g[e]]=e;Object.freeze(f);const u=["STANDARD","AUTO","FAST"];Object.freeze(u);const w={STANDARD:1,AUTO:2,FAST:3};Object.freeze(w);const m={};for(let e in w)m[w[e]]=e;Object.freeze(m);const b=eval;function y(e,t){try{e.displayName=t,Object.defineProperty(e,"name",{value:t,writable:!1,enumerable:!1,configurable:!0})}catch(e){if(p)throw e}}function k(e,t=""){return""!==t?`ðŸŽ${e}#${t}`:`ðŸŽ${e}`}function O(e){const t=Object.getOwnPropertyNames(e);t.push(...Object.getOwnPropertySymbols(e));for(const i of t){const t=Object.getOwnPropertyDescriptor(e,i);"function"==typeof t.value&&y(t.value,k(i)),"function"==typeof t.get&&y(t.get,k(i,"getter")),"function"==typeof t.set&&y(t.set,k(i,"setter"))}e.prototype&&O(e.prototype)}const E=new Set,S={UNKNOWN:0,MODULE:1,SYSTEM:2,WORLD:3};Object.freeze(S);const v={};for(let e in S)v[S[e]]=e;Object.freeze(v);class W{constructor(e=null,t=null){this.set(e,t)}set(e=null,t=null,i=!0){if(!e)return this.detect_id();if("string"!=typeof e)throw"libWrapper: PackageInfo IDs must be strings";if(e.includes("~"))return this.from_key(e);this.id=e,this.type=t,t||this.detect_type(),i&&Object.freeze(this)}set_unknown(){this.id="Â«unknownÂ»",this.type=S.UNKNOWN}equals(e){return e&&e.constructor===this.constructor&&e.id===this.id&&e.type===this.type}detect_id(t){if(this.set_unknown(),void 0===t){const e=Error.stackTraceLimit;if(Error.stackTraceLimit=1/0,t=Error().stack,Error.stackTraceLimit=e,!t)return}const i=t.matchAll(/\/(worlds|systems|modules)\/(.+?)(?=\/)/gi);if(i)for(let t of i){const i=t[1],r=t[2];if("worlds"===i){if(r==game.data.world.id)return this.set(r,S.WORLD)}else{if("systems"!==i){if("modules"===i){if(!r||r==e||!game?.modules?.has(r))continue;return this.set(r,S.MODULE)}throw new Error(`libWrapper: Invalid script type: ${i}`)}if(r==game.data.system.id)return this.set(r,S.SYSTEM)}}}detect_type(){game?.modules?game.modules.get(this.id)?.active?this.type=S.MODULE:this.id===game.data.system.id?this.type=S.SYSTEM:this.id===game.data.world.id?this.type=S.WORLD:this.type=S.UNKNOWN:this.id===e?this.type=S.MODULE:this.type=S.UNKNOWN}get known(){return this.type!=S.UNKNOWN}get exists(){switch(this.type){case S.MODULE:return game.modules.get(this.id)?.active;case S.SYSTEM:return game.data.system.id===this.id;case S.WORLD:return game.data.world.id===this.id;default:return!1}}get data(){if(!this.exists)return null;switch(this.type){case S.MODULE:return game.modules.get(this.id)?.data;case S.SYSTEM:return game.data.system.data;case S.WORLD:return game.data.world;default:return null}}get title(){if(!this.exists)return"Unknown";switch(this.type){case S.MODULE:case S.SYSTEM:case S.WORLD:return this.data.title;default:return"Unknown"}}get key(){return`${v[this.type].toLowerCase()}~${this.id}`}from_key(e){const t=e.split("~");if(2!==t.length)throw`Error: Invalid key '${e}'`;this.set(t[1],S[t[0]])}get logString(){return this.known?`${v[this.type].toLowerCase()} '${this.id}'`:"an unknown package"}get logStringCapitalized(){let e=this.logString;return e.charAt(0).toUpperCase()+e.slice(1)}get settingsName(){switch(this.type){case S.MODULE:return this.id;case S.SYSTEM:return`${this.id} [System]`;case S.WORLD:return`${this.id} [World]`;default:return this.id}}}Object.freeze(W);class A extends Error{constructor(e,t,i,...r){super(`${e}\n${t}`,...r),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.ui_msg=e,this.console_msg=t,this.notification_fn=i??"error"}onUnhandled(){}}Object.freeze(A);class T extends A{constructor(e,...t){const i=new W;super(i.known?`Internal error detected, possibly related to ${i.logString}.`:"Internal error detected.",e,"error",...t),this.package_info=i}get package_id(){return this.package_info?.id}get module(){return this.package_id}}Object.freeze(T);class I extends A{constructor(e,t,...i){let r=!1;t?t?.constructor!==W&&(t=new W(t)):(t=new W,r=!0),super(r?`Error detected, possibly in ${t.logString}.`:`Error detected in ${t.logString}.`,e,"error",...i),this.package_info=t}get package_id(){return this.package_info?.id}get module(){return this.package_id}}Object.freeze(I);const j=function(e=!1){const t=game?.user?.data;if(t)return t;const i=game.userId??game.data.userId;if(!i){if(e)return null;throw new T("Unable to obtain the current user ID")}const r=game.data.users.find((e=>e._id==i));if(!r){if(e)return null;throw new T("Unable to obtain the current user data object")}return r};class z{static init(){this.NOTIFICATION_SET=new Set,Object.seal(this)}static get ui_notifications_enabled(){try{if(function(e=!1){const t=game?.user?.isGM;if(void 0!==t)return t;const i=j(e);return i?4===i.role:null}()){if(!game?.settings?.get(e,"notify-issues-gm"))return!1}else if(!game?.settings?.get(e,"notify-issues-player"))return!1}catch(e){return console.error("libWrapper: Could not decide whether to show notifications or not. Defaulting to 'yes'.\n",e),!0}return!0}static _ui(e,t){if(!this.ui_notifications_enabled)return;if(this.NOTIFICATION_SET.has(e))return;this.NOTIFICATION_SET.add(e);let i=globalThis?.ui?.notifications;i&&i[t].call(i,`libWrapper: ${e}`,{permanent:"error"==t})}static ui(e,t="error"){globalThis.game?.ready?this._ui(e,t):Hooks.once("ready",this._ui.bind(this,e,t))}static console_ui(e,t,i="error",...r){console[i].call(console,`libWrapper: ${e}\n${t}`,...r),this.ui(`${e} (See JS console)`,i)}static conflict(e,t,i,r){let n;n=Array.isArray(t)?t.length>1?`[${t.map((e=>e.id)).join(", ")}]`:t[0].logString:t.logString,this.console_ui(i?`Potential conflict detected between ${e.logString} and ${n}.`:`Conflict detected between ${e.logString} and ${n}.`,r,i?"warn":"error")}}O(z);const C=function(e){try{const t=e.reason??e.error??e;if(!(t&&t instanceof A))return;t.ui_msg&&t.notification_fn&&z.ui(`${t.ui_msg} (See JS console)`,t.notification_fn),t.onUnhandled&&t.onUnhandled.apply(t)}catch(e){console.warn("libWrapper: Exception thrown while processing an unhandled exception.",e)}};class N{static _collect_stats(){try{return function(e,t=!1){const i=game?.user?.can;if(i)return i(e);const r=j(t);if(!r)return null;if(4===r.role)return!0;if(e in r.permissions)return r.permissions[e];const n=game.data.settings.find((e=>"core.permissions"===e.key));if(n?.value){const t=JSON.parse(n.value)[e];if(t&&t.includes(r.role))return!0}return!1}("SETTINGS_MODIFY")}catch(e){if(p)throw e;return z.console_ui("A non-critical error occurred while initializing libWrapper.","Could not read user permissions during initialization.\n","warn",e),!0}}static init(){this.collect_stats=this._collect_stats(),this.collect_stats&&(this.PACKAGES=new Set,this.CONFLICTS=new Map,Object.seal(this))}static register_package(t){this.collect_stats&&t.id!=e&&this.PACKAGES.add(t.key)}static register_conflict(e,t,i,r){if(!this.collect_stats)return;const n=`${e.key}/${t.key}`;let s=this.CONFLICTS.get(n);s||(s={count:0,ignored:0,package_info:e,other_info:t,targets:new Map},this.CONFLICTS.set(n,s));const a=i.name;let o=s.targets.get(a);o||(o={count:0,ignored:0},s.targets.set(a,o)),r?(s.ignored++,o.ignored++):(s.count++,o.count++)}static get conflicts(){return this.CONFLICTS}static get packages(){return this.PACKAGES}}class D{constructor(e,t,i){this.ignore_infos=new Set(e.map((e=>e.key))),this.targets=new Set(t),this.ignore_errors=i,Object.seal(this)}is_ignored(e,t,i){if(!i&&!this.ignore_errors)return!1;if(!this.ignore_infos.has(e.key))return!1;return void 0!==t.names.find((e=>this.targets.has(e)))}}class P{static init(){this.IGNORED=new Map,Object.seal(this)}static register_ignore(e,t,i,r){const n=new D(t,i,r),s=e.key;let a=this.IGNORED.get(s);a||(a=[],this.IGNORED.set(s,a)),a.push(n)}static clear_ignores(){this.IGNORED.clear()}static _is_ignored_oneway(e,t,i,r){const n=e.key,s=this.IGNORED.get(n);if(!s)return!1;for(const e of s)if(e.is_ignored(t,i,r))return!0;return!1}static _is_ignored(e,t,i,r){return this._is_ignored_oneway(e,t,i,r)||this._is_ignored_oneway(t,e,i,r)}static register_conflict(e,t,i,r,n){if(!t)return!1;if(Array.isArray(t)){let s=!1;return t.forEach((t=>{s|=this.register_conflict(e,t,i,r,n)})),s}if(e.constructor!==W)throw new T(`LibWrapperConflicts.register_conflict: 'package_info' must be a PackageInfo object, but got '${e}'.`);if(t.constructor!==W)throw new T(`LibWrapperConflicts.register_conflict: 'other_info' must be a PackageInfo object, but got '${t}'.`);if(null!=r&&"string"!=typeof r)throw new T(`LibWrapperConflicts.register_conflict: 'target' must be a string, or null, but got '${r}'.`);if("boolean"!=typeof n)throw new T(`LibWrapperConflicts.register_conflict: 'is_warning' must be a boolean, but got '${n}'.`);let s=!1;return!s&&this._is_ignored(e,t,i,n)&&(s=!0,h&&console.debug(`Conflict between ${e.logString} and ${t.logString} over '${i.name}' ignored through 'ignore_conflicts' API.`)),s||!1!==Hooks.call("libWrapper.ConflictDetected",e.id,t.id,r,i.frozen_names)||(s=!0,h&&console.debug(`Conflict between ${e.logString} and ${t.logString} over '${i.name}' ignored, as 'libWrapper.ConflictDetected' hook returned false.`)),N.register_conflict(e,t,i,s),!s}}class U extends A{constructor(e,t,i,r,...n){e?.constructor!==W&&(e=new W(e)),t?.constructor!==W&&(t=new W(t)),super(`Conflict detected between ${e.logString} and ${t.logString}.`,`Failed to wrap '${r}' for ${e.logString} with type OVERRIDE. An OVERRIDE wrapper for the same method has already been registered by ${t.logString}.`,"error",...n),this.package_info=e,this.conflicting_info=t,this.target=r,this._wrapper=i}get package_id(){return this.package_info?.id}get module(){return this.package_id}get conflicting_id(){return this.conflicting_info?.id}get conflicting_module(){return this.conflicting_id}onUnhandled(){super.onUnhandled(),P.register_conflict(this.package_info,this.conflicting_info,this._wrapper,this.target,!1)}}Object.freeze(U);class R extends A{constructor(e,t,i,...r){t?.constructor!==W&&(t=new W(t)),super(`Error detected in '${t.logString}'.`,i,"error",...r),this._wrapper=e,this.package_info=t}get package_id(){return this.package_info?.id}get module(){return this.package_id}}Object.freeze(R);class L{get name(){return this.names[0]}get frozen_names(){return Object.freeze(this.names),this.names}_add_name(e){this.names.includes(e)||(Object.isFrozen(this.names)&&(this.names=this.names.slice()),this.names.push(e))}_callstack_name(e,t=this.name){return k(t,e)}constructor(e,t,i,r){this.fn_name=t,this.object=e;let n=Object.getOwnPropertyDescriptor(e,t);if(n){if(n.get?._lib_wrapper){const e=n.get?._lib_wrapper;if(!(e instanceof this.constructor))throw new T(`libWrapper: '${i}' cannot be wrapped, the descriptor already has a wrapper, but of an unexpected class ('${e.constructor.name}' vs '${this.constructor.name}').`);return e._add_name(i),e}if(!1===n.configurable)throw new I(`libWrapper: '${i}' cannot be wrapped, the corresponding descriptor has 'configurable=false'.`,r);n.get?(this.is_property=!0,this._wrapped_getter=n.get,this._wrapped_setter=n.set):(this.is_property=!1,this._wrapped=n.value)}else{if(n=this._get_inherited_descriptor(),!n)throw new I(`libWrapper: Can't wrap '${i}', target does not exist or could not be found.`,r);const e=n.get?._lib_wrapper;e?this.is_property=e.is_property:n.get??n.set?this.is_property=!0:this.is_property=!1}this.names=[],this.getter_data=[],this._getter_data_id=0,this.is_property&&(this.setter_data=[],this._setter_data_id=0),this.active=!1,this._outstanding_wrappers=0,this._current_handler_id=0,this.is_property||(this._pending_wrapped_calls=[],this._pending_wrapped_calls_cnt=0),this.update_use_static_dispatch(),i||(i=t),this._add_name(i),this._wrap()}_get_handler(){const e=this._current_handler_id;if(e===this._cached_handler_id)return this._cached_handler;const t=this,i=this._callstack_name(e),r=this._wrapped??null,n={[i]:function(...i){const n=t.use_static_dispatch;return t.should_skip_wrappers(this,e,n)?t.get_wrapped(this,!1,r).apply(this,i):n?t.get_static_dispatch_chain(this).apply(this,i):t.call_wrapper(null,this,...i)},toString:function(){return t.get_wrapped(this).toString()}},s=n[i];return s.toString=n.toString,this._cached_handler=s,this._cached_handler_id=e,s}get_static_dispatch_chain(e){const t=this._getter_data_id;let i=null;if(t===this._cached_static_dispatch_chain_id&&e===this._cached_static_dispatch_chain_obj)i=this._cached_static_dispatch_chain;else{const r=()=>{i=this.call_wrapped.bind(this,null,e)},n=this.get_fn_data(!1);for(let t=n.length-1;t>=0;t--){const s=n[t],a=s.fn;s.chain?(i||r(),i=a.bind(e,i)):i=a.bind(e)}i||r(),this._cached_static_dispatch_chain_obj=e,this._cached_static_dispatch_chain_id=t,this._cached_static_dispatch_chain=i}return i}should_skip_wrappers(e,t,i){if(t==this._current_handler_id)return!1;if(t>this._current_handler_id)throw new T(`Unreachable: handler_id=${t} > this._current_handler_id=${this._current_handler_id}`);if(!this.is_property){if(this._pending_wrapped_calls_cnt<=0)return!1;if(!i){if(this._pending_wrapped_calls.indexOf(e)<0)return!1}}return!0}skip_existing_handlers(){this._current_handler_id++}_calc_use_static_dispatch(){const t=this.get_fn_data(!1);let i;for(const e of t)if(e.perf_mode)if(void 0===i)i=e.perf_mode;else if(i!==e.perf_mode){i=w.AUTO;break}return i===w.FAST||i!==w.SAFE&&!!game?.settings?.get(e,"high-performance-mode")}update_use_static_dispatch(){this.use_static_dispatch=this._calc_use_static_dispatch()}_wrap(){if(this.active)return;const e=this._callstack_name("getter"),t=this._callstack_name("setter");let i;if(this.is_property){const r=this;i={[e]:function(...e){return r.call_wrapper(null,this,...e)},[t]:function(...e){return r.call_wrapper({setter:!0},this,...e)}}}else{const r=this;i={[e]:()=>r._get_handler(),[t]:function(e){return r.set_nonproperty(e,this)}}}const r=i[e],n=i[t];r._lib_wrapper=this,Object.defineProperty(this.object,this.fn_name,{get:r,set:n,configurable:d}),this.active=!0,console.debug(`libWrapper: Wrapped '${this.name}'.`)}unwrap(){if(this.active){if(!d)throw new T("libWrapper: Cannot unwrap when PROPERTIES_CONFIGURABLE==false");delete this.object[this.fn_name],this.is_property?Object.defineProperty(this.object,this.fn_name,{get:this._wrapped_getter,set:this._wrapped_setter,configurable:!0}):this.object[this.fn_name]=this._wrapped,this.active=!1,console.debug(`libWrapper: Unwrapped '${this.name}'.`)}}_get_inherited_descriptor(){let e=Object.getPrototypeOf(this.object);for(;e;){const t=Object.getOwnPropertyDescriptor(e,this.fn_name);if(t)return t;e=Object.getPrototypeOf(e)}return null}get_wrapped(e,t=!1,i){let r;if(r=void 0!==i?i:this.is_property?t?this._wrapped_setter:this._wrapped_getter:this._wrapped,null===r&&(r=void 0),void 0===r){const i=this._get_inherited_descriptor();if(i)if(this.is_property){if(!i.get&&!i.set)throw new T("This wrapper is set up to wrap a property, but the inherited descriptor is a method.");r=t?i.set:i.get}else r=i.value??i.get.apply(e)}return void 0===r&&console.warn(`libWrapper: There is no wrapped method for '${this.name}', returning 'undefined'.`),r}call_wrapped(e,t,...i){e&&this._call_wrapper_update_state(e);const r=e?.setter??!1,n=!!e;let s,a;this.is_property||(this._pending_wrapped_calls_cnt++,n&&(s=t,this._pending_wrapped_calls.push(s)));try{a=this.get_wrapped(this.object,r)?.apply(t,i)}catch(e){throw this.is_property||this._cleanup_call_wrapped(s,n),e}return this.is_property||("function"==typeof a?.then?a=a.then((e=>(this._cleanup_call_wrapped(s,n),e)),(e=>{throw this._cleanup_call_wrapped(s,n),e})):this._cleanup_call_wrapped(s,n)),a}_cleanup_call_wrapped(e,t){if(!this._pending_wrapped_calls_cnt)throw new T(`this._pending_wrapped_calls_cnt=${this._pending_wrapped_calls_cnt} should be unreachable at this point.`);if(this._pending_wrapped_calls_cnt--,t){const t=this._pending_wrapped_calls.indexOf(e);if(t<0)throw new T("Could not find 'pend' inside 'this._pending_wrapped_calls'.");this._pending_wrapped_calls.splice(t,1)}}call_wrapper(e,t,...i){e&&this._call_wrapper_update_state(e);const r=e?.index??0,n=e?.setter??!1,s=e?.fn_data??this.get_fn_data(n),a=s[r];if(!a){if(s.length>0)throw new T(`Must not have 'data===${a}' when 'fn_data.length==${s.length}'.`);return this.call_wrapped(null,t,...i)}const o=a.fn;if(!a.chain)return o.apply(t,i);const c=r+1,l=c>=s.length,p={index:c,called:!1,valid:!0,setter:n,prev_data:a,fn_data:s},d=l?this.call_wrapped.bind(this,p,t):this.call_wrapper.bind(this,p,t);let h;this._outstanding_wrappers++;try{h=o.call(t,d,...i)}catch(e){return this._cleanup_call_wrapper_thrown(p,e)}return h="function"==typeof h?.then?h.then((e=>this._cleanup_call_wrapper(e,p,a,s,d,t,i)),(e=>this._cleanup_call_wrapper_thrown(p,e))):this._cleanup_call_wrapper(h,p,a,s,d,t,i),h}_call_wrapper_update_state(e){if("valid"in e&&!e.valid)throw new R(this,e.prev_data?.package_info,`This wrapper function for '${this.name}' is no longer valid, and must not be called.`);e.called=!0}_invalidate_state(e){if(e.valid=!1,this._outstanding_wrappers--,this._outstanding_wrappers<0)throw new T(`Outstanding wrappers = ${this._outstanding_wrappers}, should never fall below 0.`)}_cleanup_call_wrapper_thrown(e,t){throw this._invalidate_state(e),t}_cleanup_call_wrapper(e,t,i,r,n,s,a){try{if(!t.called){let o=!i.warned_conflict||N.collect_stats,c=null,l=!1;o&&(c=r.slice(t.index).filter((e=>!e.package_info.equals(i.package_info))).map((e=>e.package_info)),l=0==c.length,c.length>0&&P.register_conflict(i.package_info,c,this,null,!0)),i.type==g.WRAPPER?(z.console_ui(`Error detected in ${i.package_info.logString}.`,`The wrapper for '${i.target}' registered by ${i.package_info.logString} with type WRAPPER did not chain the call to the next wrapper, which breaks a libWrapper API requirement. This wrapper will be unregistered.`,"error"),globalThis.libWrapper.unregister(i.package_info.id,i.target),l||(e=n.apply(s,a))):i.warned_conflict||l||(z.conflict(i.package_info,c,!0,`${i.package_info.logStringCapitalized} did not chain the wrapper for '${i.target}'.`),i.warned_conflict=!0)}}finally{this._invalidate_state(t)}return e}set_nonproperty(e,t=null){if(this.is_property)throw new T("Must not call 'set_nonproperty' for a property wrapper.");t!==this.object?Object.defineProperty(t,this.fn_name,{value:e,configurable:!0,enumerable:!0,writable:!0}):(this._wrapped=e,this.skip_existing_handlers(),this.warn_classic_wrapper())}get_affected_packages(){return this.getter_data.map((e=>e.package_info))}warn_classic_wrapper(){const e=new W,t=this.get_affected_packages();if(t.length>0){P.register_conflict(e,t,this,null,!0)&&(z.conflict(e,t,!0,`Detected non-libWrapper wrapping of '${this.name}' by ${e.logString}. This will potentially lead to conflicts.`),h&&console.trace&&console.trace())}this.detected_classic_wrapper||(this.detected_classic_wrapper=[]),this.detected_classic_wrapper.push(e.key)}get_fn_data(e,t=!1){if(e&&!this.is_property)throw new T(`libWrapper: '${this.name}' does not wrap a property, thus setter=true is illegal.`);const i=e?"setter_data":"getter_data";let r=this[i];return t&&(this._outstanding_wrappers>0&&(r=this[i].slice(0),this[i]=r),this[`_${i}_id`]++),r}_post_update_fn_data(){this.update_use_static_dispatch()}sort(){for(let e of[!1,!0]){if(e&&!this.is_property)continue;this.get_fn_data(e).sort(((e,t)=>e.type-t.type||t.priority-e.priority))}}add(e){const t=e.fn;t.name&&"anonymous"!==t.name||y(t,this._callstack_name(e.package_info.id??"<unknown>"));this.get_fn_data(e.setter,!0).splice(0,0,e),this.sort(e.setter),this._post_update_fn_data()}remove(e){const t=this.get_fn_data(e.setter,!0),i=t.indexOf(e);t.splice(i,1),this._post_update_fn_data()}clear(){this.getter_data=[],this.is_property&&(this.setter_data=[]),this._post_update_fn_data()}is_empty(){return!this.getter_data.length&&!this.setter_data?.length}}O(L),Object.freeze(L);const x=new Map,M=function(t=null){x.clear();const i=t??game?.settings?.get(e,"module-priorities");if(i)for(let e of["prioritized","deprioritized"]){const t=i[e];if(!t)continue;const r="prioritized"==e?1e4:-1e4;Object.entries(t).forEach((e=>{let[t,i]=e;i.id||(i=new W(t,S.MODULE),t=i.key),x.has(t)||x.set(t,r-i.index)}))}};class F extends FormApplication{static init(){game.settings.register(e,"notify-issues-gm",{name:"Notify GM of Issues",default:!0,type:Boolean,scope:"world",config:!0,hint:"Whether to notify GMs when an issue is detected, for example a conflict."}),game.settings.register(e,"notify-issues-player",{name:"Notify Players of Issues",default:!1,type:Boolean,scope:"world",config:!0,hint:"Whether to notify Players when an issue is detected, for example a conflict."}),game.settings.register(e,"high-performance-mode",{name:"High-Performance Mode",default:!1,type:Boolean,scope:"world",config:!0,hint:"This disables most dynamic conflict detection capabilities in exchange for performance, especially relevant on low-end systems. Note that this will significantly decrease the chance conflicts are detected. As such, it is recommended to turn this off when installing or updating packages."}),game.settings.registerMenu(e,"menu",{name:"",label:"libWrapper Settings Menu",icon:"fas fa-cog",type:F,restricted:!0}),game.settings.register(e,"module-priorities",{name:"",default:{},type:Object,scope:"world",config:!1,onChange:e=>M()}),this.show_ignored_conflicts=!1,M(),Object.seal(this)}static get defaultOptions(){return{...super.defaultOptions,template:"modules/lib-wrapper/templates/settings.html",height:700,title:"libWrapper Settings Menu",width:600,classes:[e,"settings"],tabs:[{navSelector:".tabs",contentSelector:"form",initial:"name"}],submitOnClose:!1,closeOnSubmit:!1}}constructor(e={},t){super(e,t)}static showYesNoDialog(e,t){new Dialog({content:e,buttons:{yes:{icon:'<i class="fas fa-check"></i>',label:"Yes",callback:t},no:{icon:'<i class="fas fa-times"></i>',label:"No"}}}).render(!0)}getActiveWrappers(){let t=[];return E.forEach((i=>{for(let r of[!1,!0]){if(r&&!i.is_property)continue;let n=i.name;r&&(n=`${n}#set`);let s={name:n,packages:[]};i.get_fn_data(r).forEach((t=>{if(t.package_info.id==e)return;const i={name:t.package_info.settingsName,type:f[t.type],perf_mode:m[t.perf_mode]};"AUTO"==i.perf_mode?i.perf_mode=null:i.perf_mode=`, ${i.perf_mode}`,s.packages.push(i)})),i.detected_classic_wrapper&&i.detected_classic_wrapper.forEach((e=>{s.packages.push({name:new W(e).settingsName,type:"MANUAL",perf_mode:null})})),s.packages.length>0&&t.push(s)}})),t.sort(((e,t)=>t.packages.length-e.packages.length)),t}getConflicts(){if(!N.collect_stats)return null;let e=[];return N.conflicts.forEach((t=>{let i=t.count;if(this.show_ignored_conflicts&&(i+=t.ignored),0==i)return;const r=[];e.push({count:t.count,ignored:this.show_ignored_conflicts?t.ignored:0,total:i,package_id:t.package_info.settingsName,other_id:t.other_info.settingsName,targets:r}),t.targets.forEach(((e,t)=>{let i=e.count;this.show_ignored_conflicts&&(i+=e.ignored),i>0&&r.push({target:t,count:e.count,total:i,ignored:this.show_ignored_conflicts?e.ignored:0})})),r.sort(((e,t)=>e.total-t.total))})),e.sort(((e,t)=>e.total-t.total)),e}getPackages(){let t={prioritized:[],normal:[],deprioritized:[]};const i=game.settings.get(e,"module-priorities"),r=i.prioritized??{},n=i.deprioritized??{};return N.collect_stats&&(N.packages.forEach((e=>{const i=new W(e);i.key in r||i.key in n||t.normal.push(i)})),t.normal.sort(((e,t)=>e.id.localeCompare(t.id)))),Object.entries(r).forEach((e=>{let[i,r]=e;r.id||(r=new W(i,S.MODULE),i=r.key),t.prioritized.push({key:i,id:r.id,title:r.title??`${r.title} <Inactive>`,index:r.index})})),t.prioritized.sort(((e,t)=>e.index-t.index)),Object.entries(n).forEach((e=>{let[i,n]=e;i in r||(n.id||(n=new W(i,S.MODULE),i=n.key),t.deprioritized.push({key:i,id:n.id,title:n.title??`${n.title} <Inactive>`,index:n.index}))})),t.deprioritized.sort(((e,t)=>e.index-t.index)),t}getData(){return{about:{name:"libWrapper",version:l,collect_stats:N.collect_stats},wrappers:this.getActiveWrappers(),conflicts:this.getConflicts(),packages:this.getPackages(),show_ignored_conflicts:this.show_ignored_conflicts}}activateListeners(e){super.activateListeners(e);let t=this;e.find(".caret.has-nested").on("click",(function(e){const t=$(this);t.parent().find(".nested").toggleClass("active"),t.toggleClass("caret-down")})),e.find("button.reload").on("click",(function(e){t.render(!0)})),e.find(".lw-show-ignored-conflicts").on("click",(function(e){const i=$(this).find("input[type=checkbox]");t.show_ignored_conflicts=!i.prop("checked"),t.render(!0)})),e.find(".package-priority-group").on("click",(function(e){const t=$(this).find("select");t.is(":focus")||t.focus()})),e.find("button.change-priority").on("click",(function(t){const i=$(this),r=i.data("which"),n="up"===i.data("direction"),s=e.find(`.${r}`).find("option:selected"),a=n?s.prev():s.next();a.length&&(n?a.before(s):a.after(s))})),e.find("button.change-category").on("click",(function(t){const i=$(this),r=i.data("from"),n=i.data("to"),s=e.find(`.${r}`),a=e.find(`.${n}`),o=s.find("option:selected");let c=o.next();if(0==c.length&&(c=o.prev()),a.append(o),"packages-normal"==n){const e=a.find("option");e.sort(((e,t)=>$(e).val()>$(t).val()?1:-1)),a.empty().append(e)}c.length&&s.val(c.val()),s.focus()})),e.find(".submit").on("click",(function(t){for(let t of["packages-prioritized","packages-deprioritized"]){const i=e.find(`.${t}`).find("option");let r=[];i.each(((e,t)=>{r.push($(t).val())})),$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value",r.join(",")).appendTo(e)}e.submit()})),e.find(".reset").on("click",(function(t){$("input[type=hidden]").remove(),F.showYesNoDialog("<p>Resetting the package priorities will move all packages back to 'Unprioritized'. This action cannot be undone. Are you sure you want to continue?</p>",(()=>{for(let t of["packages-prioritized","packages-deprioritized"])$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value","").appendTo(e);e.submit()}))}))}async _updateObject(t,i){const r=game.settings.get(e,"module-priorities");for(let e of["prioritized","deprioritized"]){const t=`packages-${e}-hidden`;if(!(t in i))continue;const n=i[t],s=""===n?[]:n.split(",");let a=r[e]??{},o={},c=0;s.forEach((e=>{if(!e)return;const t=a[e],i=new W(e);o[e]={id:i.id,title:i.exists?i.title:t.title,index:c++}})),r[e]=o}Object.keys(r.deprioritized).forEach((e=>{e in r.prioritized&&delete r.deprioritized[e]})),await game.settings.set(e,"module-priorities",r),this.render(!0),F.showYesNoDialog("<p>It is recommended you reload this page to apply the new package priorities. Do you wish to reload?</p>",(()=>location.reload()))}}let G=!1,H=!0;function Y(e,t,i,r){const n=new L(e,t,i,r);return E.add(n),n}function V(e){let t=e.endsWith("#set");return[t?e.slice(0,-4):e,t]}function K(e,t=!1){return(t?/^[a-zA-Z_$][0-9a-zA-Z_$.]*$/:/^[a-zA-Z_$][0-9a-zA-Z_$]*$/).test(e)}function q(e,t){const i=V(e)[0],r=i.split("."),n=r.pop(),s=r.splice(0,1)[0];if(!K(s))throw new I(`Invalid target '${i}.'`,t);if("libWrapper"==s)throw new I("Not allowed to wrap libWrapper internals.",t);const a=function(e){try{return globalThis[e]??b(e)}catch(e){return}}(s);if(!a)throw new I(`Could not find target '${i}'.`,t);let o=a;for(let e of r){if(!K(e))throw new I(`Invalid target '${i}'.`,t);if(o=o[e],!o)throw new I(`Could not find target '${i}'.`,t)}return[o,n,i]}function B(e){const t=V(e)[0];for(let e of E)if(e.names.includes(t))return e;return null}function X(e,t,i){return t.get_fn_data(i).find((t=>t.package_info?.equals(e)))}function Z(e){e.is_empty()&&d&&(e.unwrap(),E.delete(e))}function J(t){let i=new W;if(!t||"string"!=typeof t)throw new I("Parameter 'package_id' must be a string.",i);if(i.exists){if(t!=i.id)throw new I(`${i.logStringCapitalized} is not allowed to call libWrapper with package_id='${t}'.`,i)}else i=new W(t);if(t==e){if(!H)throw new I(`Not allowed to call libWrapper with package_id='${t}'.`,i)}else if(!i.exists)throw new I(`Package '${t}' is not a valid package.`,i);return i}let Q=!1;class ee{static get version(){return t}static get versions(){return[i,r,n,s,a]}static get git_version(){return o}static get is_fallback(){return!1}static get debug(){return h}static set debug(e){h=e}static get LibWrapperError(){return A}static get Error(){return A}static get LibWrapperInternalError(){return T}static get InternalError(){return T}static get LibWrapperPackageError(){return I}static get PackageError(){return I}static get LibWrapperAlreadyOverriddenError(){return U}static get AlreadyOverriddenError(){return U}static get LibWrapperInvalidWrapperChainError(){return R}static get InvalidWrapperChainError(){return R}static get onUnhandledError(){return C}static version_at_least(e,t=0,a=0,o=0){return i==e?r==t?n==a?s==o:n>=a:r>t:i>e}static register(t,i,r,n="MIXED",s={}){const a=J(t);if(t!=e&&!G)throw new I("Not allowed to register wrappers before the 'libWrapperReady' hook fires",a);if(!i||"string"!=typeof i)throw new I("Parameter 'target' must be a string.",a);if(!(r&&r instanceof Function))throw new I("Parameter 'fn' must be a function.",a);if(void 0===(n=g[n.toUpperCase()])||!(n in f))throw new I(`Parameter 'type' must be one of [${_.join(", ")}].`,a);const o=s?.chain??n<g.OVERRIDE;if("boolean"!=typeof o)throw new I("Parameter 'chain' must be a boolean.",a);p&&Q&&(s.perf_mode="FAST");const c=w[s?.perf_mode?.toUpperCase()??"AUTO"];if(void 0===c||!(c in m))throw new I(`Parameter 'perf_mode' must be one of [${u.join(", ")}].`,a);const l=V(i),d=l[0],b=l[1];let y=function(e,t=null){return Y(...q(e),t)}(i,a);if(b&&!y.is_property)throw new I(`Cannot register a wrapper for '${i}' by ${a.logString}' because '${d}' is not a property, and therefore has no setter.`,a);if(X(a,y,b))throw new I(`A wrapper for '${i}' has already been registered by ${a.logString}.`,a);const k=function(t,i){if(t.id===e)return Number.MAX_VALUE;const r=x.get(t.key);return void 0!==r?r:0}(a);if(a.id!=e&&N.register_package(a),n>=g.OVERRIDE){const e=y.get_fn_data(b).find((e=>e.type==g.OVERRIDE));if(e){if(k<=e.priority)throw new U(a,e.package_info,y,i);!1!==Hooks.call("libWrapper.OverrideLost",e.package_info.id,a.id,y.name,y.frozen_names)&&(P.register_conflict(a,e.package_info,y,null,!1),z.conflict(e.package_info,a,!1,`${a.logStringCapitalized} has higher priority, and is replacing the 'OVERRIDE' registered by ${a.logString} for '${y.name}'.`))}}let $={package_info:a,target:i,setter:b,fn:r,type:n,wrapper:y,priority:k,chain:o,perf_mode:c};y.add($),(h||!p&&a.id!=e)&&(Hooks.callAll("libWrapper.Register",a.id,i,n,s),console.info(`libWrapper: Registered a wrapper for '${i}' by ${a.logString} with type ${f[n]}.`))}static unregister(t,i,r=!0){const n=J(t),s=function(e,t){const i=V(t),r=i[0],n=i[1],s=B(r);return s?X(e,s,n):null}(n,i);if(!s){if(r)throw new I(`Cannot unregister '${i}' by ${n.logString} as no such wrapper has been registered`,n);return}const a=s.wrapper;a.remove(s),Z(a),(h||n.id!=e)&&(Hooks.callAll("libWrapper.Unregister",n.id,i),console.info(`libWrapper: Unregistered the wrapper for '${i}' by ${n.logString}.`))}static unregister_all(t){const i=J(t);for(let e of E)this.unregister(i.id,e.name,!1),e.is_property&&this.unregister(i.id,`${e.name}#set`,!1);(h||i.id!=e)&&(Hooks.callAll("libWrapper.UnregisterAll",i.id),console.info(`libWrapper: Unregistered all wrapper functions by ${i.logString}.`))}static ignore_conflicts(t,i,r,n={}){const s=J(t);if(!G)throw new I("Not allowed to ignore conflicts before the 'libWrapperReady' hook fires",s);Array.isArray(i)||(i=[i]),Array.isArray(r)||(r=[r]);const a=e=>"string"==typeof e;if(!i.every(a))throw new I("Parameter 'ignore_ids' must be a string, or an array of strings.",s);if(!r.every(a))throw new I("Parameter 'targets' must be a string, or an array of strings.",s);if(!r.every((e=>K(e,!0))))throw new I("Parameter 'targets' must only contain valid targets.",s);const o=n.ignore_errors??!1;if("boolean"!=typeof o)throw new I("Parameter 'options.ignore_errors' must be a boolean.",s);const c=i.map((e=>new W(e))).filter((e=>e.exists));0!=c.length?(P.register_ignore(s,c,r,o),(h||s.id!=e)&&console.debug(`libWrapper: Ignoring conflicts involving ${s.logString} and [${c.map((e=>e.logString)).join(", ")}] for targets [${r.join(", ")}].`)):console.debug(`libWrapper: Ignoring 'ignore_conflict' call for ${s.logString} since none of the package IDs provided exist or are active.`)}}O(ee),p&&(ee._UT_unwrap_all=function(){for(let e of E)e.clear(),e.unwrap();E.clear()},ee._UT_create_wrapper_from_object=Y,ee._UT_clear=function(e){const t=B(e);t&&(t.clear(),Z(t),console.info(`libWrapper: Cleared all wrapper functions for '${e}'.`))},ee._UT_force_fast_mode=function(e){Q=e},ee._UT_get_force_fast_mode=()=>Q,ee._UT_clear_ignores=()=>P.clear_ignores()),Object.freeze(ee),delete globalThis.libWrapper,Object.defineProperty(globalThis,"libWrapper",{get:()=>ee,set:e=>{throw"libWrapper: Not allowed to re-assign the global instance of libWrapper"},configurable:!1}),function(){if(!p){globalThis.addEventListener("error",C),globalThis.addEventListener("unhandledrejection",C);try{const e="() => function "+Hooks._call.toString(),t=e.replace(/^( *).*catch\((.*)\)\s*{/gim,"$&\n$1  globalThis.libWrapper.onUnhandledError($2);");if(e===t)throw`Could not patch 'Hooks._call' method:\n${e}`;h&&console.log(`Patched Hooks._call: ${t}`);const i=b(t)?.();if("function"!=typeof i)throw`Evaluation of patched 'Hooks._call' method did not return a function:\nPatched Method: ${t}\nReturned: ${i}`;Hooks._call=i}catch(e){z.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Hooks._call' wrapper.\n","warn",e)}try{libWrapper.register("lib-wrapper","Application.prototype._render",(function(e,...t){return e(...t).catch((e=>{throw C(e),e}))}),"WRAPPER",{perf_mode:"FAST"})}catch(e){z.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Application.prototype._render' wrapper.\n","warn",e)}}}();{const d=k("libWrapperInit"),h={[d]:function(p,...d){return G=!0,function(){if(t)return;const p=game.modules?.get(e)?.data;if(!p)throw"libWrapper: Unable to find package manifest inside 'game.modules'";o=p.flags?.git_version??"unknown",c=o.length>=40?o.slice(0,7):o;const d=p.version;if(!d)throw"libWrapper: Unable to find version string inside package manifest";const h=d.match(/^([0-9]+)\.([0-9]+)\.([0-9]+).([0-9]+)(.*)$/i);if(!h)throw`libWrapper: Unable to parse version string '${d}'`;t=h[0],i=parseInt(h[1]),r=parseInt(h[2]),n=parseInt(h[3]),s=parseInt(h[4]),a=h[5].replace(/^-/gi,""),l=`${t} (${c})`}(),F.init(),N.init(),P.init(),z.init(),console.info(`libWrapper ${l}: Ready.`),Hooks.callAll("libWrapper.Ready",ee),p(...d)}};p?h[d]((()=>{})):ee.register("lib-wrapper","Game.prototype.initialize",h[d],"WRAPPER",{perf_mode:"FAST"})}H=!1;//# sourceMappingURL=lib-wrapper.js.map
