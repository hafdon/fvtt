const e="lib-wrapper";let t="",r=-1,i=-1,n=-1,s="";const a="undefined"==typeof Game,o=!!a;let l=!1;const c=["WRAPPER","MIXED","OVERRIDE"];Object.freeze(c);const p={WRAPPER:1,MIXED:2,OVERRIDE:3};Object.freeze(p);const d={};for(let e in p)d[p[e]]=e;function u(){const t=Error().stack;if(!t)return null;const r=t.matchAll(/(?<=\/modules\/).+?(?=\/)/gi);if(!r)return null;for(let t of r){var i,n;if(t=t[0],t&&t!=e&&((null===(i=game)||void 0===i||null===(n=i.modules)||void 0===n?void 0:n.has(t))??1))return t}return null}Object.freeze(d);const _=eval;function h(e,t){try{Object.defineProperty(e,"name",{value:t,writable:!1,enumerable:!1,configurable:!0})}catch(e){if(a)throw e}}const f=new Set;class g{static init(){}static get ui_enabled(){try{var t,r,i,n,s,a;if(null!==(t=game)&&void 0!==t&&null!==(r=t.user)&&void 0!==r&&r.isGM){if(null===(i=game)||void 0===i||null===(n=i.settings)||void 0===n||!n.get(e,"notify-issues-gm"))return!1}else if(null===(s=game)||void 0===s||null===(a=s.settings)||void 0===a||!a.get(e,"notify-issues-player"))return!1}catch(e){return!1}return!0}static ui(e,t="error"){var r;if(!this.ui_enabled)return;if(this.NOTIFICATION_SET){if(this.NOTIFICATION_SET.has(e))return}else this.NOTIFICATION_SET=new Set;this.NOTIFICATION_SET.add(e);let i=null===(r=ui)||void 0===r?void 0:r.notifications;i&&(i=i[t],i.call(ui.notifications,"libWrapper: "+e,{permanent:"error"==t}))}static console_ui(e,t,r="error"){console[r].call(console,`libWrapper: ${e}\n${t}`),this.ui(e+" (See JS console)",r)}static conflict(e,t,r,i){e=e?e.startsWith("¬´")&&e.endsWith("¬ª")?"module "+e:`module '${e}'`:"an unknown module",t=Array.isArray(t)?t.length>1?`[${t.join(", ")}]`:`'${t[0]}'`:`'${t}'`,this.console_ui(r?`Potential conflict detected between ${e} and ${t}.`:`Conflict detected between module ${e} and ${t}.`,i,r?"warn":"error")}}class w extends Error{constructor(e,t,r,...i){super(`${e}\n${t}`,...i),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.ui_msg=e,this.console_msg=t,this.notification_fn=r??"error"}onUnhandled(){}}Object.freeze(w);class m extends w{constructor(e,...t){const r=u();super(r?`Internal error detected, possibly related to module '${r}'.`:"Internal error detected.",e,"error",...t),this.module=r}}Object.freeze(m);class b extends w{constructor(e,t,...r){let i=!1;t||(t=t??u(),i=!0),super(t?i?`Error detected, possibly in module '${t}'.`:`Error detected in module '${t}'.`:"Error detected in unknown module.",e,"error",...r),this.module=t}}Object.freeze(b);class v extends w{constructor(e,t,r,...i){super(`Conflict detected between module '${e}' and '${t}'.`,`Failed to wrap '${r}' for module '${e}' with type OVERRIDE. The module '${t}' has already registered an OVERRIDE wrapper for the same method.`,"error",...i),this.module=e,this.conflicting_module=t,this.target=r}get conflicting_module_title(){var e,t;return null===(e=game.modules.get(this.conflicting_module))||void 0===e||null===(t=e.data)||void 0===t?void 0:t.title}onUnhandled(){super.onUnhandled(),LibWrapperStats.register_conflict(this.module,this.conflicting_module,this.target)}}Object.freeze(v);class y extends w{constructor(e,t,r,...i){super(t?`Error detected in module '${t}'.`:`Error detected in wrapper '${e.name}'.`,r,"error",...i),this._wrapper=e,this.module=t}get wrapper_name(){return this._wrapper.name}}if(Object.freeze(y),!a){const e=function(e){if(!(e instanceof w))return!1;try{e.ui_msg&&e.notification_fn&&g.ui(e.ui_msg+" (See JS console)",e.notification_fn),e.onUnhandled&&e.onUnhandled.apply(e)}catch(e){console.warn("libWrapper: Exception thrown while processing unhandled libWrapper Exception.",e)}return!1};globalThis.addEventListener("error",e),globalThis.addEventListener("unhandledrejection",e)}class E{static _collect_stats(){const e=game.userId;if(!e)return!1;const t=game.data.users.find(t=>t._id==e);return!(!t||4!==t.role)}static init(){this.collect_stats=this._collect_stats(),this.collect_stats&&(this.MODULES=new Set,this.CONFLICTS=new Map)}static register_module(t){this.collect_stats&&t!=e&&this.MODULES.add(t)}static register_conflict(e,t,r){if(!this.collect_stats)return;if(Array.isArray(t))return void t.forEach(t=>{E.register_conflict(e,t,r)});const i=`${e}/${t}`;let n=this.CONFLICTS.get(i);n||(n={count:0,module:e,other:t,targets:new Map},this.CONFLICTS.set(i,n)),n.count++,n.targets.set(r,(n.targets.get(r)??0)+1)}static get conflicts(){return this.CONFLICTS}static get modules(){return this.MODULES}}class O{get name(){return this.names[0]}_callstack_name(e,t=this.name){return`üéÅ${e}(${t})`}_callstack_call_wrapper_name(e){return`call_wrapper('${e}')`}constructor(e,t,r,i){this.fn_name=t,this.object=e;let n=Object.getOwnPropertyDescriptor(e,t);if(n){var s;if(null!==(s=n.get)&&void 0!==s&&s._lib_wrapper){var a;let e=null===(a=n.get)||void 0===a?void 0:a._lib_wrapper;if(r&&!e.names.indexOf(r)&&e.names.push(r),e&&e instanceof this.constructor)return e}if(!1===n.configurable)throw new b(`libWrapper: '${r}' cannot be wrapped, the corresponding descriptor has 'configurable=false'.`,i);n.get?(this.is_property=!0,this._wrapped_getter=n.get,this._wrapped_setter=n.set):(this.is_property=!1,this._wrapped=n.value)}else{var o;if(n=this._get_inherited_descriptor(),!n)throw new b(`libWrapper: Can't wrap '${r}', target does not exist or could not be found.`,i);const e=null===(o=n.get)||void 0===o?void 0:o._lib_wrapper;e?this.is_property=e.is_property:n.get??n.set?this.is_property=!0:this.is_property=!1}this.names=[],this.getter_data=[],this.is_property&&(this.setter_data=[]),this.active=!1,this._outstanding_wrappers=0,this._warned_detected_classic_wrapper=!1,this.is_property||(this._pending_original_calls=[],this._setter_call_count=0),r||(r=t),-1==this.names.indexOf(r)&&this.names.push(r),this._wrap()}_get_handler(){const e=this,t=this._setter_call_count,r=this._callstack_name("@handler"+t),i=this._wrapped;return{[r]:function(...r){if(e.should_skip_wrappers(this,t))return e.get_wrapped.call(e,this,!1,i).apply(this,r);{const t=e.call_wrapper.bind(e,null,this);return h(t,e._callstack_call_wrapper_name("<start>")),t(...r)}}}[r]}_wrap(){if(this.active)return;const e=this._callstack_name("@getter"),t=this._callstack_name("@setter");let r;if(this.is_property){const i=this;r={[e]:function(...e){return i.call_wrapper(null,this,...e)},[t]:function(...e){return i.call_wrapper({setter:!0},this,...e)}}}else{const i=this;r={[e]:function(){return i._get_handler()},[t]:function(e){return i.set_nonproperty(e,this)}}}const i=r[e],n=r[t];i._lib_wrapper=this,Object.defineProperty(this.object,this.fn_name,{get:i,set:n,configurable:o}),this.active=!0,console.debug(`libWrapper: Wrapped '${this.name}'.`)}unwrap(){if(this.active){if(!o)throw new m("libWrapper: Cannot unwrap when PROPERTIES_CONFIGURABLE==false");delete this.object[this.fn_name],this.is_property?Object.defineProperty(this.object,this.fn_name,{get:this._wrapped_getter,set:this._wrapped_setter,configurable:!0}):this.object[this.fn_name]=this._wrapped,this.active=!1,console.debug(`libWrapper: Unwrapped '${this.name}'.`)}}_get_inherited_descriptor(){let e=Object.getPrototypeOf(this.object),t=null;for(;e;){if(t=Object.getOwnPropertyDescriptor(e,this.fn_name),t)return t;e=Object.getPrototypeOf(e)}return null}get_wrapped(e,t=!1,r=this._wrapped){let i;if(i=this.is_property?t?this._wrapped_setter:this._wrapped_getter:r,void 0===i){const r=this._get_inherited_descriptor();if(r)if(this.is_property){if(r.get??!r.set)throw new m("This wrapper is set up to wrap a property, but the inherited descriptor is a method.");i=t?r.set:r.get}else i=r.value??r.get.apply(e)}return void 0===i&&console.warn(`libWrapper: There is no wrapped method for '${this.name}', returning 'undefined'.`),i}_call_wrapped(e,t,r=!1){var i;let n;this.is_property||(n=e,this._pending_original_calls.push(n));let s=void 0;try{const i=this.get_wrapped(this.object,r);s=null==i?void 0:i.apply(e,t)}catch(e){throw this.is_property||this._cleanup_call_wrapped(null,n),e}return this.is_property||(s="function"==typeof(null===(i=s)||void 0===i?void 0:i.then)?s.then(e=>this._cleanup_call_wrapped(e,n),e=>{throw this._cleanup_call_wrapped(null,n),e}):this._cleanup_call_wrapped(s,n)),s}_cleanup_call_wrapped(e,t){const r=this._pending_original_calls.indexOf(t);if(r<0)throw new m("Could not find 'pend' inside 'this._pending_original_calls'.");return this._pending_original_calls.splice(r,1),e}should_skip_wrappers(e,t){if(t==this._setter_call_count)return!1;if(t>this._setter_call_count)throw new m(`Unreachable: setter_call_count=${t} > this._setter_call_count=${this._setter_call_count}`);return!(this._pending_original_calls.indexOf(e)<0)}call_wrapper(e,t,...r){var i,n;const s=(null==e?void 0:e.index)??0,a=(null==e?void 0:e.setter)??!1,o=(null==e?void 0:e.fn_data)??(a?this.setter_data:this.getter_data);if(e){var l;if("valid"in e&&!e.valid)throw new y(this,null===(l=e.prev_data)||void 0===l?void 0:l.module,`This wrapper function for '${this.name}' is no longer valid, and must not be called.`);e.called=!0}const c=o[s];if(!c)return this._call_wrapped(t,r,a);const d=c.fn;if(c.type>=p.OVERRIDE)return d.apply(t,r);const u={setter:a,called:!1,valid:!0,index:s+1,prev_data:c,fn_data:o},_=this.call_wrapper.bind(this,u,t);h(_,this._callstack_call_wrapper_name((null===(i=o[u.index])||void 0===i?void 0:i.module)??"<finish>")),this._outstanding_wrappers++;let f=void 0;try{f=d.call(t,_,...r)}catch(e){return this._cleanup_call_wrapper_thrown(u,e)}return f="function"==typeof(null===(n=f)||void 0===n?void 0:n.then)?f.then(e=>this._cleanup_call_wrapper(e,u,c,o,_,t,...r),e=>this._cleanup_call_wrapper_thrown(u,e)):this._cleanup_call_wrapper(f,u,c,o,_,t,...r),f}_invalidate_state(e){if(e.valid=!1,this._outstanding_wrappers--,this._outstanding_wrappers<0)throw new m(`Outstanding wrappers = ${this._outstanding_wrappers}, should never fall below 0.`)}_cleanup_call_wrapper_thrown(e,t){throw this._invalidate_state(e),t}_cleanup_call_wrapper(e,t,r,i,n,s,...a){try{if(!t.called){let o=!r.warned_conflict||E.collect_stats,l=null,c=!1;o&&(l=i.slice(t.index).filter(e=>e.module!=r.module).map(e=>e.module),c=0==l.length,E.register_conflict(r.module,l,this.name)),r.type==p.WRAPPER?(g.console_ui(`Error detected in module '${r.module}'.`,`The wrapper for '${r.target}' registered by module '${r.module}' with type WRAPPER did not chain the call to the next wrapper, which breaks a libWrapper API requirement. This wrapper will be unregistered.`,"error"),globalThis.libWrapper.unregister(r.module,r.target),c||(e=n.apply(s,a))):r.warned_conflict||c||(g.conflict(r.module,l,!0,`Module '${r.module}' did not chain the wrapper for '${r.target}'.`),r.warned_conflict=!0)}}finally{this._invalidate_state(t)}return e}set_nonproperty(e,t=null){if(this.is_property)throw new m("Must not call 'set_nonproperty' for a property wrapper.");t!==this.object?Object.defineProperty(t,this.fn_name,{value:e,configurable:!0,enumerable:!0,writable:!0}):(this._wrapped=e,this._setter_call_count++,this.warn_classic_wrapper())}get_affected_modules(){return this.getter_data.map(e=>e.module)}warn_classic_wrapper(){let e=u();e=e?`¬´${e}¬ª`:"¬´unknown¬ª";const t=this.get_affected_modules();E.register_conflict(e,t,this.name),t.length>0&&(g.conflict(e,t,!0,`Detected non-libWrapper wrapping of '${this.name}' by ${e}. This will potentially lead to conflicts.`),l&&console.trace&&console.trace()),this.detected_classic_wrapper||(this.detected_classic_wrapper=[]),this.detected_classic_wrapper.push(e)}get_fn_data(e,t=!1){if(e&&!this.is_property)throw new m(`libWrapper: '${this.name}' does not wrap a property, thus setter=true is illegal.`);const r=e?"setter_data":"getter_data";return t&&this._outstanding_wrappers>0&&(this[r]=this[r].slice(0)),this[r]}sort(){for(let e of[!1,!0]){if(e&&!this.is_property)continue;this.get_fn_data(e).sort((e,t)=>e.type-t.type||t.priority-e.priority)}}add(e){const t=e.fn;t.name&&"anonymous"!==t.name||h(t,this._callstack_name(e.module??"<unknown>"));this.get_fn_data(e.setter,!0).splice(0,0,e),this.sort(e.setter)}remove(e){const t=this.get_fn_data(e.setter,!0),r=t.indexOf(e);t.splice(r,1)}clear(){this.getter_data=[],this.is_property&&(this.setter_data=[])}is_empty(){var e;return!(this.getter_data.length||null!==(e=this.setter_data)&&void 0!==e&&e.length)}}Object.freeze(O);class W extends FormApplication{static init(){game.settings.register(e,"notify-issues-gm",{name:"Notify GM of Issues",default:!0,type:Boolean,scope:"world",config:!0,hint:"Whether to notify GMs when an issue is detected, for example a conflict."}),game.settings.register(e,"notify-issues-player",{name:"Notify Players of Issues",default:!1,type:Boolean,scope:"world",config:!0,hint:"Whether to notify Players when an issue is detected, for example a conflict."}),game.settings.registerMenu(e,"menu",{name:"",label:"libWrapper Settings Menu",icon:"fas fa-cog",type:W,restricted:!0}),game.settings.register(e,"module-priorities",{name:"",default:{},type:Object,scope:"world",config:!1,onChange:e=>globalThis.libWrapper.load_priorities()})}static get defaultOptions(){return{...super.defaultOptions,template:"modules/lib-wrapper/templates/settings.html",height:700,title:"libWrapper Settings Menu",width:600,classes:[e,"settings"],tabs:[{navSelector:".tabs",contentSelector:"form",initial:"name"}],submitOnClose:!1,closeOnSubmit:!1}}constructor(e={},t){super(e,t)}static showYesNoDialog(e,t){new Dialog({content:e,buttons:{yes:{icon:'<i class="fas fa-check"></i>',label:"Yes",callback:t},no:{icon:'<i class="fas fa-times"></i>',label:"No"}}}).render(!0)}getActiveWrappers(){let t=[];return f.forEach(r=>{for(let i of[!1,!0]){if(i&&!r.is_property)continue;let n=r.name;i&&(n+="#set");let s={name:n,modules:[]};r.get_fn_data(i).forEach(t=>{t.module!=e&&s.modules.push({name:t.module,type:d[t.type]})}),r.detected_classic_wrapper&&r.detected_classic_wrapper.forEach(e=>{s.modules.push({name:e,type:"MANUAL"})}),s.modules.length>0&&t.push(s)}}),t.sort((e,t)=>t.modules.length-e.modules.length),t}getConflicts(){if(!E.collect_stats)return null;let e=[];return E.conflicts.forEach(t=>{let r=[];e.push({count:t.count,module:t.module,other:t.other,targets:r}),t.targets.forEach((e,t)=>{r.push({target:t,count:e})}),r.sort((e,t)=>e.count-t.count)}),e.sort((e,t)=>e.count-t.count),e}getModules(){let t={prioritized:[],normal:[],deprioritized:[]};const r=game.settings.get(e,"module-priorities"),i=r.prioritized??{},n=r.deprioritized??{};return E.collect_stats&&(E.modules.forEach(e=>{const r=game.modules.get(e).data;e in i||e in n||t.normal.push({id:e,title:r.title})}),t.normal.sort((e,t)=>e.id-t.id)),Object.entries(i).forEach(e=>{var r;const[i,n]=e,s=null===(r=game.modules.get(i))||void 0===r?void 0:r.data;t.prioritized.push({id:i,title:(null==s?void 0:s.title)??n.title+" <Inactive>",index:n.index})}),t.prioritized.sort((e,t)=>e.index-t.index),Object.entries(n).forEach(e=>{var r;const[n,s]=e;if(n in i)return;const a=null===(r=game.modules.get(n))||void 0===r?void 0:r.data;t.deprioritized.push({id:n,title:(null==a?void 0:a.title)??s.title+" <Inactive>",index:s.index})}),t.deprioritized.sort((e,t)=>e.index-t.index),t}getData(){return{about:{name:"libWrapper",version:t,collect_stats:E.collect_stats},wrappers:this.getActiveWrappers(),conflicts:this.getConflicts(),modules:this.getModules()}}activateListeners(e){super.activateListeners(e);let t=this;e.find(".caret.has-nested").on("click",(function(e){const t=$(this);t.parent().find(".nested").toggleClass("active"),t.toggleClass("caret-down")})),e.find("button#reload").on("click",(function(e){t.render(!0)})),e.find(".module-priority-group").on("click",(function(e){const t=$(this).find("select");t.is(":focus")||t.focus()})),e.find("button.change-priority").on("click",(function(t){const r=$(this),i=r.data("which"),n="up"===r.data("direction"),s=e.find("#"+i).find("option:selected"),a=n?s.prev():s.next();a.length&&(n?a.before(s):a.after(s))})),e.find("button.change-category").on("click",(function(t){const r=$(this),i=r.data("from"),n=r.data("to"),s=e.find("#"+i),a=e.find("#"+n),o=s.find("option:selected");let l=o.next();if(0==l.length&&(l=o.prev()),a.append(o),"modules-normal"==n){const e=a.find("option");e.sort((e,t)=>$(e).val()>$(t).val()?1:-1),a.empty().append(e)}l.length&&s.val(l.val()),s.focus()})),e.find("#submit").on("click",(function(t){for(let t of["modules-prioritized","modules-deprioritized"]){const r=e.find("#"+t).find("option");let i=[];r.each((e,t)=>{i.push($(t).val())}),$("<input>").attr("type","hidden").attr("name",t+"-hidden").attr("value",i.join(",")).appendTo(e)}e.submit()})),e.find("#reset").on("click",(function(t){$("input[type=hidden]").remove(),W.showYesNoDialog("<p>Resetting the module priorities will move all modules back to 'Unprioritized'. This action cannot be undone. Are you sure you want to continue?</p>",()=>{for(let t of["modules-prioritized","modules-deprioritized"])$("<input>").attr("type","hidden").attr("name",t+"-hidden").attr("value","").appendTo(e);e.submit()})}))}async _updateObject(t,r){const i=game.settings.get(e,"module-priorities");for(let e of["prioritized","deprioritized"]){const t=`modules-${e}-hidden`;if(!(t in r))continue;const n=r[t],s=""===n?[]:n.split(",");let a=i[e]??{},o={},l=0;s.forEach(e=>{var t;if(!e)return;const r=a[a],i=null===(t=game.modules.get(e))||void 0===t?void 0:t.data;o[e]={title:(null==i?void 0:i.title)??(null==r?void 0:r.title)??"<Unknown>",index:l++}}),i[e]=o}Object.keys(i.deprioritized).forEach(e=>{e in i.prioritized&&delete i.deprioritized[e]}),await game.settings.set(e,"module-priorities",i),this.render(!0),W.showYesNoDialog("<p>It is recommended you reload this page to apply the new module priorities. Do you wish to reload?</p>",()=>location.reload())}}Object.freeze(W);let I=!1,j=!0;const T=new Map;class z{static get version(){return t}static get versions(){return[r,i,n,s]}static get is_fallback(){return!1}static get debug(){return l}static set debug(e){l=e}static get LibWrapperError(){return w}static get Error(){return w}static get LibWrapperInternalError(){return m}static get InternalError(){return m}static get LibWrapperModuleError(){return b}static get ModuleError(){return b}static get LibWrapperAlreadyOverriddenError(){return v}static get AlreadyOverriddenError(){return v}static get LibWrapperInvalidWrapperChainError(){return y}static get InvalidWrapperChainError(){return y}static _create_wrapper_from_object(e,t,r,i){const n=new O(e,t,r,i);return this.wrappers.add(n),n}static _split_target_and_setter(e){let t=e.endsWith("#set");return[t?e.slice(0,-4):e,t]}static _valid_identifier(e){return/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(e)}static _get_target_object(e,t){const r=this._split_target_and_setter(e)[0],i=r.split("."),n=i.pop(),s=i.splice(0,1)[0];if(!this._valid_identifier(s))throw new b(`Invalid target '${r}.'`,t);if("libWrapper"==s)throw new b("Not allowed to wrap libWrapper internals.",t);const a=function(e){try{return globalThis[e]??_(e)}catch(e){return}}(s);if(!a)throw new b(`Could not find target '${r}'.`,t);let o=a;for(let e of i){if(!this._valid_identifier(e))throw new b(`Invalid target '${r}'.`,t);if(o=o[e],!o)throw new b(`Could not find target '${r}'.`,t)}return[o,n,r]}static _create_wrapper(e,t=null){return this._create_wrapper_from_object(...this._get_target_object(e),t)}static _find_wrapper_by_name(e){const t=this._split_target_and_setter(e)[0];for(let e of this.wrappers)if(-1!=e.names.indexOf(t))return e;return null}static _find_module_data_in_wrapper(e,t,r){return t.get_fn_data(r).find(t=>t.module==e)}static _find_module_data_with_target(e,t){const r=this._split_target_and_setter(t),i=r[0],n=r[1],s=this._find_wrapper_by_name(i);return s?this._find_module_data_in_wrapper(e,s,n):null}static _get_default_priority(t,r){if(t===e)return Number.MAX_VALUE;const i=T.get(t);return void 0!==i?i:0}static _unwrap_if_possible(e){e.is_empty()&&o&&(e.unwrap(),this.wrappers.delete(e))}static _clear(e){const t=this._find_wrapper_by_name(e);t&&(t.clear(),this._unwrap_if_possible(t),console.info(`libWrapper: Cleared all wrapper functions for '${e}'.`))}static _unwrap_all(){for(let e of this.wrappers)e.clear(),e.unwrap();this.wrappers.clear()}static _validate_module(t){var r;const i=u();if(!t||"string"!=typeof t)throw new b("Parameter 'module' must be a string.",i);if(t!=e&&(null===(r=game.modules.get(t))||void 0===r||!r.active))throw new b(`Module '${t}' is not a valid module.`,i);if(t==e&&!j)throw new b(`Not allowed to call libWrapper with module='${t}'.`,i);if(i&&t!=i)throw new b(`Module '${i}' is not allowed to call libWrapper with module='${t}'.`,i)}static load_priorities(t=null){var r,i;const n=u();if(n)throw new b(`Module '${n}' is not allowed to call libWrapper.load_priorities()`,n);T.clear();const s=t??(null===(r=game)||void 0===r||null===(i=r.settings)||void 0===i?void 0:i.get(e,"module-priorities"));if(s)for(let e of["prioritized","deprioritized"]){const t=s[e];if(!t)continue;const r="prioritized"==e?1e4:-1e4;Object.entries(t).forEach(e=>{const[t,i]=e;T.has(t)||T.set(t,r-i.index)})}}static register(t,r,i,n="MIXED"){if(this._validate_module(t),t!=e&&!I)throw new b("Not allowed to register wrappers before the 'libWrapperReady' hook fires",t);if(!r||"string"!=typeof r)throw new b("Parameter 'target' must be a string.",t);if(!(i&&i instanceof Function))throw new b("Parameter 'fn' must be a function.",t);if(void 0===(n=p[n.toUpperCase()])||!(n in d))throw new b(`Parameter 'type' must be one of [${c.join(", ")}].`,t);const s=this._split_target_and_setter(r),a=s[0],o=s[1];let u=this._create_wrapper(r,t);if(o&&!u.is_property)throw new b(`Cannot register a wrapper for '${r}' by '${t}' because '${a}' is not a property, and therefore has no setter.`,t);if(this._find_module_data_in_wrapper(t,u,o))throw new b(`Module '${t}' has already registered a wrapper for '${r}'.`,t);const _=this._get_default_priority(t,r);if(n==p.OVERRIDE){const e=u.get_fn_data(o).find(e=>e.type==p.OVERRIDE);if(e){if(_<=e.priority)throw new v(t,e.module,u.name);E.register_conflict(t,e.module,u.name),g.conflict(e.module,t,!1,`Module '${t}' has higher priority, and is replacing the OVERRIDE registered by '${e.module}' for '${u.name}'.`)}}t!=e&&E.register_module(t);let h={module:t,target:r,setter:o,fn:i,type:n,wrapper:u,priority:_};u.add(h),(l||t!=e)&&console.info(`libWrapper: Registered a wrapper for '${r}' by '${t}' with type ${d[n]}.`)}static unregister(t,r,i=!0){this._validate_module(t);const n=this._find_module_data_with_target(t,r);if(!n){if(i)throw new b(`Cannot unregister '${r}' by '${t}' as no such wrapper has been registered`,t);return}const s=n.wrapper;s.remove(n),this._unwrap_if_possible(s),(l||t!=e)&&console.info(`libWrapper: Unregistered the wrapper for '${r}' by '${t}'.`)}static clear_module(e){this._validate_module(e);for(let t of this.wrappers)this.unregister(e,t.name,!1),t.is_property&&this.unregister(e,t.name+"#set",!1);console.info(`libWrapper: Cleared all wrapper functions by module '${e}'.`)}}var x,R,k;k=f,(R="wrappers")in(x=z)?Object.defineProperty(x,R,{value:k,enumerable:!0,configurable:!0,writable:!0}):x[R]=k,Object.freeze(z),delete globalThis.libWrapper,Object.defineProperty(globalThis,"libWrapper",{get:()=>z,set:e=>{throw"libWrapper: Not allowed to re-assign the global instance of libWrapper"},configurable:!1});{const o=function(a,...o){I=!0,function(){var a,o,l;if(t)return;const c=null===(a=game.modules)||void 0===a||null===(o=a.get(e))||void 0===o||null===(l=o.data)||void 0===l?void 0:l.version;if(!c)throw"libWrapper: Unable to find version string inside 'game.modules'";const p=c.match(/^([0-9]+)\.([0-9]+)\.([0-9]+)[.-]?(.*)$/i);if(!p)throw`libWrapper: Unable to parse version string '${c}'`;t=p[0],r=parseInt(p[1]),i=parseInt(p[2]),n=parseInt(p[3]),s=parseInt(p[4]),isNaN(s)&&(s=p[4])}(),W.init(),E.init(),g.init(),z.load_priorities(),console.info(`libWrapper ${t}: Ready.`),Hooks.callAll("libWrapperReady",z);return a(...o)};a?o(()=>{}):z.register("lib-wrapper","Game.prototype.initialize",o,"WRAPPER")}j=!1;//# sourceMappingURL=lib-wrapper.js.map
