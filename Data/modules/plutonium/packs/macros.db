{"name":"Create Named Token","type":"script","img":"modules/plutonium/media/img/blank.png","scope":"global","command":"(async () => {\r\n\tcanvas.stage.once(\"click\", async evt => {\r\n\t\ttry {\r\n\t\t\tconst {x, y} = evt.data.getLocalPosition(canvas.stage);\r\n\r\n\t\t\tconst name = await InputUiUtil.pGetUserString({title: \"Token Name\"});\r\n\t\t\tif (!name) return;\r\n\r\n\t\t\tawait game.modules.get(\"plutonium\").api.token.pCreateToken({name, xScene: x, yScene: y});\r\n\t\t} catch (e) {\r\n\t\t\tui.notifications.error(`Failed to create token! ${VeCt.STR_SEE_CONSOLE}`);\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t});\r\n\r\n\tui.notifications.info(\"Click on the canvas to spawn a token!\");\r\n})();\r\n","folder":null,"sort":0,"permission":{"default":0},"_id":"3uodczsxlchv0ao4"}
{"name":"Import to Selected Tokens","type":"script","img":"modules/plutonium/media/icon/fontawesome/atom-solid.svg","scope":"global","command":"(async () => {\r\n\ttry {\r\n\t\tconst tokens = [...canvas.tokens.controlled].filter(it => it.actor);\r\n\t\tif (!tokens.length) return ui.notifications.warn(`Please select some tokens (which have actors) first!`);\r\n\r\n\t\tconst actors = tokens.map(it => it.actor).unique();\r\n\t\tif (!actors.length) return ui.notifications.warn(`Please select some tokens (which have actors) first!`);\r\n\r\n\t\t// If there is only a single actor, open the standard importer flow for this actor (as though opening it from a sheet)\r\n\t\tif (actors.length === 1) {\r\n\t\t\tawait game.modules.get(\"plutonium\").api.importer.pOpen({actor: actors[0]});\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// region If we are importing to multiple tokens, create a single dummy actor as a surrogate import target, then copy the resulting changes to each actor once the import wizard is closed.\r\n\t\tconst ACTOR_TYPE_PREFERENCE = [\"character\", \"npc\", \"vehicle\"];\r\n\t\tconst actorTypes = actors\r\n\t\t\t.map(it => it.type)\r\n\t\t\t.unique()\r\n\t\t\t.sort((a, b) => ACTOR_TYPE_PREFERENCE.indexOf(a) - ACTOR_TYPE_PREFERENCE.indexOf(b));\r\n\r\n\t\tif (actorTypes.length > 1) ui.notifications.warn(`Multiple actor types found in selected tokens\\u2014the importer will run as though importing to a \"${actorTypes[0]}\"-type actor.`);\r\n\r\n\t\tui.notifications.info(`You are importing to ${actors.length} actors\\u2014updates will be applied, as a batch, when the importer is closed.`);\r\n\r\n\t\tconst dummyActor = await Actor.create(\r\n\t\t\t{\r\n\t\t\t\tname: \"Temp\",\r\n\t\t\t\ttype: actorTypes[0],\r\n\t\t\t\tflags: {srd5e: {isImporterTempActor: true}},\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\trenderSheet: false,\r\n\t\t\t\ttemporary: true,\r\n\t\t\t},\r\n\t\t);\r\n\t\tconst baseData = dummyActor.toJSON();\r\n\t\t// Remove our temp flag, to avoid generating a junk diff later\r\n\t\tdelete baseData.flags.srd5e;\r\n\r\n\t\tconst importer = await game.modules.get(\"plutonium\").api.importer.pOpen({actor: dummyActor});\r\n\r\n\t\tawait game.modules.get(\"plutonium\").api.util.apps.pAwaitAppClose(importer);\r\n\r\n\t\tui.notifications.info(`Applying updates...`);\r\n\r\n\t\tconst finalData = dummyActor.toJSON();\r\n\r\n\t\t// Remove our temp flags, to avoid applying them to the target actors\r\n\t\tMiscUtil.delete(finalData, \"flags\", \"srd5e\", \"isImporterTempActor\");\r\n\t\tif (!Object.keys(MiscUtil.get(finalData, \"flags\", \"srd5e\") || {}).length) MiscUtil.delete(finalData, \"flags\", \"srd5e\");\r\n\r\n\t\tlet isAnyUpdate = false;\r\n\r\n\t\tconst DIFF_OBJECT_PROPS = [\"data\", \"token\", \"flags\"];\r\n\t\tfor (const prop of DIFF_OBJECT_PROPS) {\r\n\t\t\tif (!baseData[prop] && !finalData[prop]) continue;\r\n\r\n\t\t\tconst diff = foundry.utils.diffObject(baseData[prop], finalData[prop]);\r\n\r\n\t\t\tif (!Object.keys(diff).length) continue;\r\n\t\t\tisAnyUpdate = true;\r\n\r\n\t\t\tfor (const actor of actors) await actor.update({[prop]: diff});\r\n\t\t}\r\n\r\n\t\tconst DIFF_EMBEDDED_PROPS = [\r\n\t\t\t{prop: \"items\", documentName: \"Item\"},\r\n\t\t\t{prop: \"effects\", documentName: \"ActiveEffect\"},\r\n\t\t];\r\n\t\tfor (const {prop, documentName} of DIFF_EMBEDDED_PROPS) {\r\n\t\t\tif (!finalData[prop]?.length) continue;\r\n\t\t\tisAnyUpdate = true;\r\n\r\n\t\t\tfor (const actor of actors) {\r\n\t\t\t\tconst cpyEmbeds = MiscUtil.copy(finalData[prop]);\r\n\r\n\t\t\t\tconst [toCreates, toUpdates] = cpyEmbeds.segregate(embed => {\r\n\t\t\t\t\t// Fix any `origin`s, e.g. for active effects, which may point to invalid actors\r\n\t\t\t\t\tif (embed.origin && typeof embed.origin === \"string\") {\r\n\t\t\t\t\t\tconst originSpl = embed.origin.split(\".\");\r\n\t\t\t\t\t\t// E.g. `Actor.<id>.Item.<id>`\r\n\t\t\t\t\t\t// If the actor ID is `null`, then repair it, using our current actor's ID\r\n\t\t\t\t\t\tif (originSpl.length === 4 && originSpl[1] === \"null\") {\r\n\t\t\t\t\t\t\toriginSpl[1] = actor.id;\r\n\t\t\t\t\t\t\tembed.origin = originSpl.join(\".\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn actor[prop].get(embed._id) == null;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (toCreates.length) await actor.createEmbeddedDocuments(documentName, toCreates, {addFeatures: false, keepId: true});\r\n\t\t\t\tif (toUpdates.length) await actor.updateEmbeddedDocuments(documentName, toUpdates, {addFeatures: false});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (isAnyUpdate) ui.notifications.info(`Updates applied!`);\r\n\t\telse ui.notifications.warn(`Found no updates to apply!`);\r\n\t\t// endregion\r\n\t} catch (e) {\r\n\t\tui.notifications.error(`Importing failed! ${VeCt.STR_SEE_CONSOLE}`);\r\n\t\tthrow e;\r\n\t}\r\n})();\r\n","folder":null,"sort":0,"permission":{"default":0},"_id":"jrv77q94idjuglaf"}
